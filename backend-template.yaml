AWSTemplateFormatVersion: '2010-09-09'
Description: 'Backend Infrastructure for Financial News Engine'

Parameters:
  EnvironmentName:
    Description: Environment name
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production
  
  VpcStackName:
    Description: Name of the VPC CloudFormation stack
    Type: String
    Default: financial-news-vpc
  
  InstanceType:
    Description: EC2 instance type for the backend servers
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
      - t3.large
  
  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: Must be the name of an existing EC2 KeyPair.
  
  AMIId:
    Description: AMI ID for the EC2 instances
    Type: AWS::EC2::Image::Id
    Default: ami-0261755bbcb8c4a84  # Ubuntu 20.04 LTS in us-east-1 (update for your region)
  
  ElasticsearchEndpoint:
    Description: Endpoint URL for Elasticsearch
    Type: String
    Default: https://your-elasticsearch-endpoint.es.amazonaws.com
  
  ElasticsearchApiKey:
    Description: API Key for Elasticsearch
    Type: String
    NoEcho: true
  
  ElasticsearchIndex:
    Description: Elasticsearch index name
    Type: String
    Default: financial_news
  
  EsNumberOfShards:
    Description: Number of shards for Elasticsearch index
    Type: Number
    Default: 3
  
  EsNumberOfReplicas:
    Description: Number of replicas for Elasticsearch index
    Type: Number
    Default: 2
  
  MinSize:
    Description: Minimum number of EC2 instances in the Auto Scaling Group
    Type: Number
    Default: 2
    MinValue: 1
  
  MaxSize:
    Description: Maximum number of EC2 instances in the Auto Scaling Group
    Type: Number
    Default: 6
    MinValue: 1
  
  DesiredCapacity:
    Description: Desired number of EC2 instances in the Auto Scaling Group
    Type: Number
    Default: 2
    MinValue: 1
  
  SSHLocation:
    Description: The IP address range that can be used to SSH to the EC2 instances
    Type: String
    MinLength: 9
    MaxLength: 18
    Default: 0.0.0.0/0
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
  
  PublicSubnet1ID:
    Description: ID of the first public subnet
    Type: AWS::EC2::Subnet::Id
  
  PublicSubnet2ID:
    Description: ID of the second public subnet
    Type: AWS::EC2::Subnet::Id
  
  VPCID:
    Description: ID of the VPC
    Type: AWS::EC2::VPC::Id
  
  PrivateSubnet1ID:
    Description: ID of the first private subnet
    Type: AWS::EC2::Subnet::Id
  
  PrivateSubnet2ID:
    Description: ID of the second private subnet
    Type: AWS::EC2::Subnet::Id

Mappings:
  RegionMap:
    us-east-1:
      AMI: ami-0261755bbcb8c4a84  # Ubuntu 20.04 LTS
    us-east-2:
      AMI: ami-0430580de6244e02e  # Ubuntu 20.04 LTS
    us-west-1:
      AMI: ami-04669a22aad391419  # Ubuntu 20.04 LTS
    us-west-2:
      AMI: ami-0efa651876de2a5ce  # Ubuntu 20.04 LTS
    eu-west-1:
      AMI: ami-0a8e758f5e873d1c1  # Ubuntu 20.04 LTS

Resources:
  # IAM Role for EC2 instances
  BackendInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Path: /
      Policies:
        - PolicyName: ESAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'es:ESHttpGet'
                  - 'es:ESHttpPost'
                  - 'es:ESHttpPut'
                  - 'es:ESHttpDelete'
                Resource: '*'
        - PolicyName: S3AccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                  - 's3:ListBucket'
                Resource: 
                  - 'arn:aws:s3:::financial-news-assets/*'
                  - 'arn:aws:s3:::financial-news-assets'

  # Instance Profile for EC2 instances
  BackendInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref BackendInstanceRole

  # Security Group for Backend EC2 instances
  BackendSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for backend servers
      VpcId: 
        Fn::ImportValue: !Sub "${VpcStackName}-VPCID"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref SSHLocation
        - IpProtocol: tcp
          FromPort: 5000  # Flask default port
          ToPort: 5000
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-backend-sg
        - Key: Environment
          Value: !Ref EnvironmentName

  # Security Group for Application Load Balancer
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Application Load Balancer
      VpcId:
        Fn::ImportValue: !Sub "${VpcStackName}-VPCID"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-alb-sg
        - Key: Environment
          Value: !Ref EnvironmentName

  # Launch Template for Auto Scaling Group
  BackendLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${EnvironmentName}-backend-lt
      VersionDescription: Initial version
      LaunchTemplateData:
        ImageId: !Ref AMIId
        InstanceType: !Ref InstanceType
        KeyName: !Ref KeyName
        SecurityGroupIds:
          - !Ref BackendSecurityGroup
        IamInstanceProfile:
          Name: !Ref BackendInstanceProfile
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            
            # Exit on error, print commands, prevent unbound variables
            set -euo pipefail
            
            # Function to log with timestamps
            log() {
              echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a /var/log/user-data.log
            }
            
            # Create a status file to track progress
            STATUS_FILE="/var/log/backend-init-status.txt"
            echo "STARTED" > $STATUS_FILE
            
            log "Starting backend initialization..."
            
            # Update system packages
            log "Updating system packages"
            apt-get update || { log "ERROR: apt-get update failed"; echo "APT_UPDATE_FAILED" > $STATUS_FILE; exit 1; }
            apt-get upgrade -y || { log "WARNING: apt-get upgrade failed, continuing anyway"; }
            
            # Install Python and development tools
            log "Installing Python and development tools"
            apt-get install -y python3 python3-pip python3-dev gcc git wget unzip curl jq || { 
              log "ERROR: Failed to install required packages"
              echo "PACKAGE_INSTALL_FAILED" > $STATUS_FILE
              exit 1
            }
            
            # Install CloudWatch agent
            log "Installing CloudWatch agent"
            if [ ! -f "/opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl" ]; then
              wget https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb -O /tmp/amazon-cloudwatch-agent.deb || {
                log "ERROR: Failed to download CloudWatch agent"
                echo "CLOUDWATCH_DOWNLOAD_FAILED" > $STATUS_FILE
                exit 1
              }
              
              dpkg -i /tmp/amazon-cloudwatch-agent.deb || {
                log "ERROR: Failed to install CloudWatch agent"
                echo "CLOUDWATCH_INSTALL_FAILED" > $STATUS_FILE
                exit 1
              }
            else
              log "CloudWatch agent already installed"
            fi
            
            # Create app directory
            log "Creating application directory"
            mkdir -p /opt/financial-news-engine
            cd /opt/financial-news-engine
            
            # Create Flask application
            log "Creating Flask application"
            cat > app.py << 'EOL'
            from flask import Flask, jsonify, request
            import os
            import logging
            import sys
            import json
            import time
            from datetime import datetime
            
            # Configure logging
            log_dir = "logs"
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
                
            logger = logging.getLogger("backend")
            logger.setLevel(logging.INFO)
            
            # Create console handler
            ch = logging.StreamHandler(sys.stdout)
            ch.setLevel(logging.INFO)
            
            # Create file handler
            fh = logging.FileHandler(os.path.join(log_dir, "backend.log"))
            fh.setLevel(logging.INFO)
            
            # Create formatter and add to handlers
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            ch.setFormatter(formatter)
            fh.setFormatter(formatter)
            
            # Add handlers to logger
            logger.addHandler(ch)
            logger.addHandler(fh)
            
            # Create Flask app
            app = Flask(__name__)
            
            # Load environment variables
            es_url = os.environ.get('ELASTICSEARCH_URL')
            es_api_key = os.environ.get('ELASTICSEARCH_API_KEY')
            es_index = os.environ.get('ELASTICSEARCH_INDEX')
            
            @app.route('/health', methods=['GET'])
            def health():
                """Health check endpoint"""
                status = {
                    "status": "healthy",
                    "timestamp": datetime.now().isoformat(),
                    "version": "1.0",
                    "environment": os.environ.get('ENVIRONMENT', 'development')
                }
                
                # Add Elasticsearch connection status if configured
                if es_url and es_api_key:
                    try:
                        # Import here to avoid requiring the package if not used
                        from elasticsearch import Elasticsearch
                        
                        # Test connection with a short timeout
                        es = Elasticsearch([es_url], api_key=es_api_key, request_timeout=5)
                        es_info = es.info()
                        
                        status["elasticsearch"] = {
                            "connected": True,
                            "version": es_info.get("version", {}).get("number", "unknown")
                        }
                    except Exception as e:
                        status["elasticsearch"] = {
                            "connected": False,
                            "error": str(e)
                        }
                        # Mark as degraded if ES connection fails
                        status["status"] = "degraded"
                        logger.warning(f"Elasticsearch connection failed: {str(e)}")
                else:
                    status["elasticsearch"] = {
                        "connected": False,
                        "error": "Not configured"
                    }
                
                return jsonify(status)
            
            @app.route('/diagnostic', methods=['GET'])
            def diagnostic():
                """Diagnostic information endpoint"""
                import platform
                import socket
                import psutil
                
                # Collect system information
                system_info = {
                    "hostname": socket.gethostname(),
                    "platform": platform.system(),
                    "platform_version": platform.version(),
                    "python_version": platform.python_version(),
                    "cpu_percent": psutil.cpu_percent(),
                    "memory_percent": psutil.virtual_memory().percent,
                    "disk_percent": psutil.disk_usage('/').percent
                }
                
                # Add environment variables (redacted)
                env_vars = {}
                for key, value in os.environ.items():
                    if key.lower() in ('api_key', 'key', 'secret', 'password', 'token'):
                        env_vars[key] = '***REDACTED***'
                    else:
                        env_vars[key] = value
                
                return jsonify({
                    "system": system_info,
                    "environment": env_vars,
                    "timestamp": datetime.now().isoformat()
                })
                
            @app.route('/ping', methods=['GET'])
            def ping():
                """Simple ping endpoint for quick health checks"""
                return jsonify({"status": "ok"})
            
            # Startup validation endpoint to verify the server is properly configured
            @app.route('/setup-validate', methods=['GET'])
            def setup_validate():
                """Validates the server setup"""
                import subprocess
                
                # Check if we can resolve DNS
                dns_check = {"success": False}
                try:
                    result = subprocess.run(['nslookup', 'google.com'], capture_output=True, text=True, timeout=5)
                    dns_check = {
                        "success": result.returncode == 0,
                        "output": result.stdout
                    }
                except Exception as e:
                    dns_check["error"] = str(e)
                
                # Check disk space
                disk_check = {"success": False}
                try:
                    disk = psutil.disk_usage('/')
                    disk_check = {
                        "success": disk.percent < 90,  # Less than 90% used is success
                        "percent_used": disk.percent,
                        "free_gb": round(disk.free / (1024**3), 2)
                    }
                except Exception as e:
                    disk_check["error"] = str(e)
                
                # Check ES connectivity if configured
                es_check = {"configured": False}
                if es_url and es_api_key:
                    es_check["configured"] = True
                    try:
                        from elasticsearch import Elasticsearch
                        es = Elasticsearch([es_url], api_key=es_api_key, request_timeout=5)
                        es_info = es.info()
                        es_check["success"] = True
                        es_check["version"] = es_info.get("version", {}).get("number", "unknown")
                    except Exception as e:
                        es_check["success"] = False
                        es_check["error"] = str(e)
                
                # Overall status
                all_success = all([
                    dns_check.get("success", False),
                    disk_check.get("success", False),
                    # Only require ES if configured
                    not es_check.get("configured", False) or es_check.get("success", False)
                ])
                
                return jsonify({
                    "success": all_success,
                    "timestamp": datetime.now().isoformat(),
                    "checks": {
                        "dns": dns_check,
                        "disk": disk_check,
                        "elasticsearch": es_check
                    }
                })
            
            if __name__ == '__main__':
                logger.info("Starting Flask application")
                port = int(os.environ.get('PORT', 5000))
                app.run(host='0.0.0.0', port=port)
            EOL
            
            # Create requirements.txt with version pinning
            log "Creating requirements.txt"
            cat > requirements.txt << 'EOL'
            flask==2.3.3
            flask-cors==4.0.0
            elasticsearch==8.9.0
            requests==2.31.0
            python-dotenv==1.0.0
            gunicorn==21.2.0
            psutil==5.9.5
            EOL
            
            # Install dependencies with error handling
            log "Installing Python dependencies"
            pip3 install --no-cache-dir -r requirements.txt || {
              log "ERROR: Failed to install Python dependencies"
              echo "PIP_INSTALL_FAILED" > $STATUS_FILE
              exit 1
            }
            
            # Create logs directory
            log "Creating logs directory"
            mkdir -p /opt/financial-news-engine/logs
            chmod 755 /opt/financial-news-engine/logs
            
            # Create systemd service with environment variables and proper error handling
            log "Creating systemd service"
            cat > /etc/systemd/system/financial-news.service << 'EOL'
            [Unit]
            Description=Financial News Engine Flask App
            After=network.target
            
            [Service]
            User=root
            WorkingDirectory=/opt/financial-news-engine
            ExecStart=/usr/local/bin/gunicorn --workers 3 --bind 0.0.0.0:5000 app:app --access-logfile logs/access.log --error-logfile logs/error.log --capture-output --log-level info
            Restart=always
            # Set a 60s startup timeout to ensure the service has enough time to initialize
            TimeoutStartSec=60
            # Ensure the service restarts after 10s if it fails
            RestartSec=10
            Environment=ELASTICSEARCH_URL=${ElasticsearchEndpoint}
            Environment=ELASTICSEARCH_API_KEY=${ElasticsearchApiKey}
            Environment=ELASTICSEARCH_INDEX=${ElasticsearchIndex}
            Environment=ES_NUMBER_OF_SHARDS=${EsNumberOfShards}
            Environment=ES_NUMBER_OF_REPLICAS=${EsNumberOfReplicas}
            Environment=ENVIRONMENT=${EnvironmentName}
            
            [Install]
            WantedBy=multi-user.target
            EOL
            
            # Create .env file for local development and testing
            log "Creating .env file"
            cat > /opt/financial-news-engine/.env << 'EOL'
            ELASTICSEARCH_URL=${ElasticsearchEndpoint}
            ELASTICSEARCH_API_KEY=${ElasticsearchApiKey}
            ELASTICSEARCH_INDEX=${ElasticsearchIndex}
            ES_NUMBER_OF_SHARDS=${EsNumberOfShards}
            ES_NUMBER_OF_REPLICAS=${EsNumberOfReplicas}
            ENVIRONMENT=${EnvironmentName}
            EOL
            
            # Create a startup verification script
            log "Creating startup verification script"
            cat > /opt/financial-news-engine/verify_startup.sh << 'EOL'
            #!/bin/bash
            set -e
            
            echo "Verifying backend service startup..."
            
            # Wait for the service to start
            for i in {1..12}; do
              if curl -s http://localhost:5000/ping > /dev/null; then
                echo "Service is responding to ping"
                break
              fi
              
              if [ $i -eq 12 ]; then
                echo "ERROR: Service failed to start within 60 seconds"
                exit 1
              fi
              
              echo "Waiting for service to start (attempt $i/12)..."
              sleep 5
            done
            
            # Verify setup validation endpoint
            SETUP_RESULT=$(curl -s http://localhost:5000/setup-validate)
            SUCCESS=$(echo $SETUP_RESULT | grep -o '"success": true' || echo "")
            
            if [ -n "$SUCCESS" ]; then
              echo "Startup verification successful"
              exit 0
            else
              echo "WARNING: Setup validation failed:"
              echo $SETUP_RESULT
              exit 1
            fi
            EOL
            chmod +x /opt/financial-news-engine/verify_startup.sh
            
            # Enable and start service with validation
            log "Enabling service"
            systemctl daemon-reload
            systemctl enable financial-news.service
            
            log "Starting service"
            systemctl start financial-news.service
            
            # Check initial service status
            systemctl status financial-news.service --no-pager || {
              log "WARNING: Service may have failed to start, checking logs"
              journalctl -u financial-news.service --no-pager -n 20
            }
            
            # Configure CloudWatch agent for Ubuntu
            log "Configuring CloudWatch agent"
            mkdir -p /opt/aws/amazon-cloudwatch-agent/etc/
            cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOL'
            {
              "agent": {
                "metrics_collection_interval": 60,
                "run_as_user": "root"
              },
              "logs": {
                "logs_collected": {
                  "files": {
                    "collect_list": [
                      {
                        "file_path": "/var/log/syslog",
                        "log_group_name": "/financial-news/system",
                        "log_stream_name": "{instance_id}"
                      },
                      {
                        "file_path": "/var/log/user-data.log",
                        "log_group_name": "/financial-news/initialization",
                        "log_stream_name": "{instance_id}"
                      },
                      {
                        "file_path": "/opt/financial-news-engine/logs/backend.log",
                        "log_group_name": "/financial-news/application",
                        "log_stream_name": "{instance_id}-app"
                      },
                      {
                        "file_path": "/opt/financial-news-engine/logs/error.log",
                        "log_group_name": "/financial-news/application",
                        "log_stream_name": "{instance_id}-error"
                      },
                      {
                        "file_path": "/opt/financial-news-engine/logs/access.log",
                        "log_group_name": "/financial-news/application",
                        "log_stream_name": "{instance_id}-access"
                      }
                    ]
                  }
                }
              },
              "metrics": {
                "metrics_collected": {
                  "disk": {
                    "measurement": [
                      "used_percent"
                    ],
                    "resources": [
                      "/"
                    ]
                  },
                  "mem": {
                    "measurement": [
                      "mem_used_percent"
                    ]
                  },
                  "statsd": {
                    "metrics_collection_interval": 10,
                    "metrics_aggregation_interval": 60,
                    "service_address": ":8125"
                  }
                }
              }
            }
            EOL
            
            # Start CloudWatch agent
            log "Starting CloudWatch agent"
            systemctl daemon-reload
            systemctl enable amazon-cloudwatch-agent
            systemctl start amazon-cloudwatch-agent || {
              log "WARNING: CloudWatch agent failed to start"
            }
            
            # Verify the service is running correctly
            log "Verifying service startup"
            /opt/financial-news-engine/verify_startup.sh || {
              log "ERROR: Service verification failed"
              echo "SERVICE_VERIFICATION_FAILED" > $STATUS_FILE
              # Don't exit here, still try to signal completion
            }
            
            # Final status
            log "Initialization completed successfully"
            echo "COMPLETED" > $STATUS_FILE
            
            # Signal completion
            log "Signaling completion to CloudFormation"
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource BackendAutoScalingGroup --region ${AWS::Region} || {
              log "WARNING: Failed to signal CloudFormation"
            }

  # Auto Scaling Group for Backend Servers
  BackendAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn: LoadBalancerListener
    Properties:
      AutoScalingGroupName: !Sub ${EnvironmentName}-backend-asg
      LaunchTemplate:
        LaunchTemplateId: !Ref BackendLaunchTemplate
        Version: !GetAtt BackendLaunchTemplate.LatestVersionNumber
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
      VPCZoneIdentifier:
        - Fn::ImportValue: !Sub "${VpcStackName}-PrivateSubnet1ID"
        - Fn::ImportValue: !Sub "${VpcStackName}-PrivateSubnet2ID"
      TargetGroupARNs:
        - !Ref BackendTargetGroup
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-backend-instance
          PropagateAtLaunch: true
        - Key: Environment
          Value: !Ref EnvironmentName
          PropagateAtLaunch: true

  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${EnvironmentName}-backend-alb
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '60'
      Subnets:
        - Fn::ImportValue: !Sub "${VpcStackName}-PublicSubnet1ID"
        - Fn::ImportValue: !Sub "${VpcStackName}-PublicSubnet2ID"
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-backend-alb
        - Key: Environment
          Value: !Ref EnvironmentName

  # Target Group for Backend Servers
  BackendTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${EnvironmentName}-backend-tg
      Port: 5000
      Protocol: HTTP
      VpcId:
        Fn::ImportValue: !Sub "${VpcStackName}-VPCID"
      HealthCheckIntervalSeconds: 30
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: '20'
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-backend-tg
        - Key: Environment
          Value: !Ref EnvironmentName

  # Listener for Application Load Balancer (HTTP)
  LoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref BackendTargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP

  # Auto Scaling Policies
  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref BackendAutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: 70.0

  # CloudWatch Alarms
  HighCPUAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: Alarm if CPU too high for more than 5 minutes
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 85
      AlarmActions:
        - !Ref BackendSNSTopic
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref BackendAutoScalingGroup
      ComparisonOperator: GreaterThanThreshold

  # SNS Topic for Alarms
  BackendSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub ${EnvironmentName}-backend-alerts
      TopicName: !Sub ${EnvironmentName}-backend-alerts

Outputs:
  BackendALBDNSName:
    Description: DNS Name of the Application Load Balancer
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub "${AWS::StackName}-BackendALBDNSName"
  
  BackendALBFullQualifiedDNSName:
    Description: Full DNS Name of the Application Load Balancer
    Value: !Sub https://${ApplicationLoadBalancer.DNSName}
    Export:
      Name: !Sub "${AWS::StackName}-BackendALBURL"
  
  BackendAutoScalingGroupName:
    Description: Auto Scaling Group Name
    Value: !Ref BackendAutoScalingGroup
    Export:
      Name: !Sub "${AWS::StackName}-BackendASGName"
  
  BackendSecurityGroupId:
    Description: Security Group ID for Backend Servers
    Value: !Ref BackendSecurityGroup
    Export:
      Name: !Sub "${AWS::StackName}-BackendSGID"
  
  BackendSNSTopicArn:
    Description: ARN of the SNS Topic for Backend Alerts
    Value: !Ref BackendSNSTopic
    Export:
      Name: !Sub "${AWS::StackName}-BackendSNSTopicARN"
  
  ApiGatewayUrl:
    Description: "URL of the Backend API endpoint"
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub "${AWS::StackName}-ApiGatewayUrl"
  
  ElasticsearchSettings:
    Description: "Elasticsearch configuration used"
    Value: !Sub "URL: ${ElasticsearchEndpoint}, Index: ${ElasticsearchIndex}"
    Export:
      Name: !Sub "${AWS::StackName}-ElasticsearchSettings" 