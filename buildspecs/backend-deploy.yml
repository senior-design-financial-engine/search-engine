version: 0.2
phases:
  install:
    runtime-versions:
      python: 3.9
    commands:
      - echo 'Starting backend deployment process'
      - pip install --upgrade awscli
      - pip install boto3
      - aws --version
  pre_build:
    commands:
      - echo 'Environment variables:'
      - echo ENVIRONMENT=$ENVIRONMENT
      - echo BACKEND_STACK_NAME=$BACKEND_STACK_NAME
      - echo 'Current directory:' $(pwd)
      - ls -la
      - cd backend || echo 'Backend directory not found, proceeding anyway'
      - mkdir -p scripts
      - echo 'Creating deployment scripts...'
      - |
        cat > scripts/deploy.sh << 'EOF'
        #!/bin/bash
        cd /opt/financial-news-engine
        
        # Check if backend.zip exists and extract it
        if [ -f "/tmp/backend.zip" ]; then
          echo "Extracting backend.zip..."
          unzip -o /tmp/backend.zip -d .
          if [ $? -ne 0 ]; then
            echo "Error extracting backend.zip"
          fi
        else
          echo "backend.zip not found, checking for app.py in S3"
        fi
        
        # Check if app.py exists, if not try to extract from backend-api.yaml in S3
        if [ ! -f "app.py" ]; then
          echo "Trying to fetch app.py from backend-api.yaml in S3"
          
          # Get the S3 bucket name
          BUCKET_NAME=$(aws cloudformation describe-stacks --query "Stacks[?contains(StackName, 'financial-news')].Outputs[?OutputKey=='AssetsBucketName'].OutputValue" --output text)
          
          if [ -n "$BUCKET_NAME" ]; then
            echo "Found assets bucket: $BUCKET_NAME"
            
            # Download the backend-api.yaml file
            aws s3 cp s3://$BUCKET_NAME/api/backend-api.yaml /tmp/backend-api.yaml
            
            if [ -f "/tmp/backend-api.yaml" ]; then
              echo "Extracting app.py from backend-api.yaml"
              # Extract app_code section
              grep -A10000 "app_code: |" /tmp/backend-api.yaml | tail -n +2 | sed '/^[a-zA-Z]/,$d' | sed 's/^  //' > app.py
              
              # Make it executable
              chmod +x app.py
              
              # Extract requirements if needed
              if [ ! -f "requirements.txt" ]; then
                echo "Extracting requirements.txt from backend-api.yaml"
                grep -A10000 "requirements: |" /tmp/backend-api.yaml | tail -n +2 | sed '/^[a-zA-Z]/,$d' | sed 's/^  //' > requirements.txt
              fi
              
              # Extract service file
              grep -A10000 "service_definition: |" /tmp/backend-api.yaml | tail -n +2 | sed '/^[a-zA-Z]/,$d' | sed 's/^  //' > /etc/systemd/system/financial-news.service
            else
              echo "Failed to download backend-api.yaml"
            fi
          else
            echo "Could not determine S3 bucket name"
          fi
        fi
        
        # Create a default service file if it doesn't exist
        if [ ! -f "/etc/systemd/system/financial-news.service" ]; then
          echo "Creating default service file"
          cat > /etc/systemd/system/financial-news.service << EOL
        [Unit]
        Description=Financial News API Service
        After=network.target

        [Service]
        Type=simple
        User=ubuntu
        WorkingDirectory=/opt/financial-news-engine
        Environment=PYTHONUNBUFFERED=1
        ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py
        Restart=on-failure
        RestartSec=5
        StandardOutput=append:/opt/financial-news-engine/logs/service-output.log
        StandardError=append:/opt/financial-news-engine/logs/service-error.log
        SyslogIdentifier=financial-news

        [Install]
        WantedBy=multi-user.target
        EOL
        fi
        
        # Install requirements
        if [ -f "requirements.txt" ]; then
          echo "Installing Python requirements"
          pip3 install -r requirements.txt
        else
          echo "requirements.txt not found, installing minimal requirements"
          pip3 install flask flask-cors boto3 elasticsearch requests psutil
        fi
        
        # Reload systemd and start service
        systemctl daemon-reload
        systemctl enable financial-news.service
        
        # Check if we have an app.py file before starting the service
        if [ -f "app.py" ]; then
          echo "Starting financial-news service"
          systemctl restart financial-news.service
        else
          echo "ERROR: No app.py found, service not started"
          exit 1
        fi
        EOF
      - chmod +x scripts/deploy.sh
      - |
        cat > scripts/before_install.sh << 'EOF'
        #!/bin/bash
        # Create necessary directories
        mkdir -p /opt/financial-news-engine
        mkdir -p /opt/financial-news-engine/logs
        mkdir -p /opt/financial-news-engine/deploy_scripts
        
        # Install required dependencies
        apt-get update -y || yum update -y
        apt-get install -y python3-pip jq unzip || yum install -y python3-pip jq unzip
        
        # Set proper permissions
        chmod 755 /opt/financial-news-engine
        chmod 755 /opt/financial-news-engine/logs
        chmod 755 /opt/financial-news-engine/deploy_scripts
        EOF
      - chmod +x scripts/before_install.sh
      - |
        cat > scripts/create_env_file.sh << 'EOF'
        #!/bin/bash
        # Create .env file with environment variables by fetching from SSM Parameter Store
        echo "Fetching credentials from SSM Parameter Store using get-parameters-by-path..."

        # Use get-parameters-by-path to get all parameters at once
        echo "Retrieving all parameters at once"
        PARAMS=$(aws ssm get-parameters-by-path --path "/financial-news/" --recursive --with-decryption --query "Parameters[*].[Name,Value]" --output json)

        # Check if parameters were retrieved successfully
        if [ -z "$PARAMS" ] || [ "$PARAMS" == "[]" ]; then
            echo "WARNING: No parameters found at path /financial-news/"
            # Fall back to individual parameter retrieval
            function get_parameter() {
                local param_name=$1
                local default_value=$2
                
                echo "Fetching parameter: $param_name"
                local value=$(aws ssm get-parameter --name "$param_name" --with-decryption --query "Parameter.Value" --output text 2>/dev/null)
                local exit_code=$?
                
                if [ $exit_code -eq 0 ] && [ -n "$value" ] && [ "$value" != "None" ]; then
                    echo "Successfully retrieved parameter: $param_name"
                    echo "$value"
                else
                    echo "WARNING: Failed to retrieve parameter: $param_name - using default value: $default_value"
                    echo "$default_value"
                fi
            }
            
            # Get parameters with default fallbacks
            ES_URL=$(get_parameter "/financial-news/elasticsearch-url" "https://fc9fa0b183414ca28ea4c7288ad74e23.us-east-1.aws.found.io:443")
            ES_API_KEY=$(get_parameter "/financial-news/elasticsearch-api-key" "default-api-key")
            ES_INDEX=$(get_parameter "/financial-news/elasticsearch-index" "financial_news")
            ES_SHARDS=$(get_parameter "/financial-news/es-number-of-shards" "1")
            ES_REPLICAS=$(get_parameter "/financial-news/es-number-of-replicas" "0")
            ENV=$(get_parameter "/financial-news/environment" "development")
        else
            # Extract each parameter value from the JSON response
            echo "Parameters retrieved successfully, extracting values"
            ES_URL=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/elasticsearch-url") | .[1]')
            ES_API_KEY=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/elasticsearch-api-key") | .[1]')
            ES_INDEX=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/elasticsearch-index") | .[1]')
            ES_SHARDS=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/es-number-of-shards") | .[1]')
            ES_REPLICAS=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/es-number-of-replicas") | .[1]')
            ENV=$(echo $PARAMS | jq -r '.[] | select(.[0]=="/financial-news/environment") | .[1]')
        fi

        # Fallback to defaults if values are empty
        ES_URL=${ES_URL:-"https://fc9fa0b183414ca28ea4c7288ad74e23.us-east-1.aws.found.io:443"}
        ES_API_KEY=${ES_API_KEY:-"default-api-key"}
        ES_INDEX=${ES_INDEX:-"financial_news"}
        ES_SHARDS=${ES_SHARDS:-"1"}
        ES_REPLICAS=${ES_REPLICAS:-"0"}
        ENV=${ENV:-"development"}

        # Create the .env file
        mkdir -p /opt/financial-news-engine
        mkdir -p /opt/financial-news-engine/logs
        cat > /opt/financial-news-engine/.env << EOL
        ELASTICSEARCH_URL=$ES_URL
        ELASTICSEARCH_API_KEY=$ES_API_KEY
        ELASTICSEARCH_INDEX=$ES_INDEX
        ES_NUMBER_OF_SHARDS=$ES_SHARDS
        ES_NUMBER_OF_REPLICAS=$ES_REPLICAS
        ENVIRONMENT=$ENV
        CORS_ALLOWED_ORIGINS=https://financialnewsengine.com,https://www.financialnewsengine.com,http://localhost:3000
        EOL

        # Set secure permissions
        chmod 600 /opt/financial-news-engine/.env
        echo "Created .env file with environment variables from SSM Parameter Store"
        EOF
      - chmod +x scripts/create_env_file.sh
      - |
        cat > appspec.yml << 'EOF'
        version: 0.0
        os: linux
        files:
          - source: dist/backend.zip
            destination: /tmp/
        hooks:
          BeforeInstall:
            - location: scripts/before_install.sh
              timeout: 300
              runas: root
          AfterInstall:
            - location: scripts/deploy.sh
              timeout: 300
              runas: root
            - location: scripts/create_env_file.sh
              timeout: 300
              runas: root
        EOF
  build:
    commands:
      - echo 'Checking AWS CLI configuration:'
      - aws sts get-caller-identity || echo 'AWS credentials issue - continuing anyway'
      - echo 'Checking for backend stack:'
      - aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME || echo 'Stack not found or permission issue - continuing deployment anyway'
      - echo 'Listing available stacks:'
      - aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE || echo 'Unable to list stacks - continuing anyway'
      - echo 'Proceeding with simple deployment without AWS CLI dependencies'
      - echo 'Deployment preparation complete'
  post_build:
    commands:
      - echo 'Verifying deployment artifacts:'
      - ls -la
      - echo 'Starting ASG instance refresh to deploy the new code to all instances'
      - |
        # Get the Auto Scaling Group name from the CloudFormation stack
        ASG_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='BackendAutoScalingGroupName'].OutputValue" --output text)
        
        if [ -n "$ASG_NAME" ]; then
          echo "Found Auto Scaling Group: $ASG_NAME"
          
          # Start an instance refresh with 50% min healthy percentage
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences '{"MinHealthyPercentage": 50, "InstanceWarmup": 300}' \
            --query "InstanceRefreshId" --output text)
          
          if [ -n "$REFRESH_ID" ]; then
            echo "Started instance refresh with ID: $REFRESH_ID"
            
            # Wait for up to 5 minutes for the refresh to complete
            MAX_RETRIES=30
            for i in $(seq 1 $MAX_RETRIES); do
              STATUS=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name $ASG_NAME \
                --instance-refresh-ids $REFRESH_ID \
                --query "InstanceRefreshes[0].Status" --output text)
              
              echo "Instance refresh status: $STATUS (Attempt $i/$MAX_RETRIES)"
              
              if [ "$STATUS" = "Successful" ]; then
                echo "Instance refresh completed successfully"
                break
              elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
                echo "Instance refresh failed or was cancelled"
                # Continue deployment even if refresh failed - don't fail the build
                break
              fi
              
              if [ $i -eq $MAX_RETRIES ]; then
                echo "Timed out waiting for instance refresh to complete. Current status: $STATUS"
                echo "Deployment will continue, refresh will continue in the background."
              else
                echo "Waiting 10 seconds before checking status again..."
                sleep 10
              fi
            done
          else
            echo "WARNING: Could not start instance refresh. Deployment may require manual instance refresh."
          fi
        else
          echo "WARNING: Could not find Auto Scaling Group name. Instance refresh could not be performed."
        fi
      - echo 'Backend deployment completed successfully'
artifacts:
  files:
    - "backend/appspec.yml"
    - "backend/scripts/**/*"
    - "backend/dist/backend.zip"
  discard-paths: no 