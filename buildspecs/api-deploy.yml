version: 0.2

phases:
  install:
    runtime-versions:
      python: 3.9
    commands:
      - "echo \"Installing required tools\""
      - "pip install pyyaml boto3 awscli jq"
  
  pre_build:
    commands:
      - "echo \"Preparing API code for deployment\""
      - "cd backend || (echo \"Backend directory not found, using project root\"; cd .)"
      - "mkdir -p api/deploy/api-scripts"
      - "cp backend.py api/deploy/app.py || cp app.py api/deploy/app.py || echo \"Using fallback app.py\""
      - "cp requirements.txt api/deploy/requirements.txt || echo \"Using fallback requirements.txt\""
      
      # Create fallback app.py and requirements.txt if they don't exist
      - |
        if [ ! -f "api/deploy/app.py" ]; then
          echo "Creating fallback app.py with basic health endpoint"
          mkdir -p api/deploy
          cat > api/deploy/app.py << 'EOF'
        #!/usr/bin/env python3
        """
        Financial News Engine API - Fallback Application
        
        This is a basic fallback application that provides a health endpoint.
        """
        
        import os
        import logging
        from flask import Flask, jsonify, request
        from dotenv import load_dotenv
        
        # Set up logging
        logging.basicConfig(
            filename='/opt/financial-news-engine/logs/backend.log',
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        logger = logging.getLogger(__name__)
        
        # Load environment variables
        load_dotenv()
        
        app = Flask(__name__)
        
        @app.route('/health', methods=['GET'])
        def health_check():
            """Health check endpoint"""
            logger.info("Health check endpoint accessed")
            return jsonify({
                "status": "healthy",
                "message": "Financial News Engine API is running"
            })
            
        @app.route('/', methods=['GET'])
        def index():
            """Root endpoint"""
            logger.info("Root endpoint accessed")
            return jsonify({
                "name": "Financial News Engine API",
                "version": "1.0.0",
                "status": "ok"
            })
            
        if __name__ == '__main__':
            port = int(os.environ.get('PORT', 5000))
            app.run(host='0.0.0.0', port=port)
        EOF
        fi
        
        if [ ! -f "api/deploy/requirements.txt" ]; then
          echo "Creating fallback requirements.txt"
          mkdir -p api/deploy
          cat > api/deploy/requirements.txt << 'EOF'
        flask==2.0.1
        python-dotenv==0.19.0
        elasticsearch==7.14.0
        requests==2.26.0
        EOF
        fi
      
      # Get assets bucket name from CloudFormation
      - "echo \"Getting assets bucket name from CloudFormation\""
      - "export ASSETS_BUCKET_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='AssetsBucketName'].OutputValue\" --output text)"
      - "echo \"Assets bucket name: $ASSETS_BUCKET_NAME\""
      
      # Create deployment scripts
      - "echo \"Creating deployment scripts\""
      - |
        cat > api/deploy/api-scripts/create_env_file.sh << 'EOF'
        #!/bin/bash
        # Fetch environment variables from SSM Parameter Store
        echo "Fetching credentials from SSM Parameter Store - parameters are managed by the CICD stack" >&2

        # Create necessary directories
        sudo mkdir -p /opt/financial-news-engine
        sudo mkdir -p /opt/financial-news-engine/logs
        sudo mkdir -p /opt/financial-news-engine/deploy_scripts
        
        # Set proper permissions for log directory
        sudo chown -R ubuntu:ubuntu /opt/financial-news-engine/logs
        sudo chmod -R 755 /opt/financial-news-engine/logs

        # Set default values in case parameter retrieval fails
        ES_URL=""
        ES_API_KEY=""
        ES_INDEX="financial_news"
        ES_SHARDS="3"
        ES_REPLICAS="2"
        ENV="production"

        # Get parameters from SSM Parameter Store with error handling and verbosity
        function get_parameter() {
            local param_name=$1
            local default_value=$2

            echo "Fetching parameter: $param_name" >&2
            local value=$(aws ssm get-parameter --name "$param_name" --with-decryption --query "Parameter.Value" --output text 2>/dev/null)
            local exit_code=$?

            if [ $exit_code -eq 0 ] && [ ! -z "$value" ]; then
                echo "Successfully retrieved parameter: $param_name" >&2
                echo "$value"
            else
                echo "WARNING: Failed to retrieve parameter: $param_name - using default value: $default_value" >&2
                echo "$default_value"
            fi
        }

        # Get parameters with default fallbacks
        ES_URL=$(get_parameter "/financial-news/elasticsearch-url" "https://your-elasticsearch-endpoint.es.amazonaws.com")
        ES_API_KEY=$(get_parameter "/financial-news/elasticsearch-api-key" "default-api-key")
        ES_INDEX=$(get_parameter "/financial-news/elasticsearch-index" "financial_news")
        ES_SHARDS=$(get_parameter "/financial-news/es-number-of-shards" "3")
        ES_REPLICAS=$(get_parameter "/financial-news/es-number-of-replicas" "2")
        ENV=$(get_parameter "/financial-news/environment" "development")

        # Create the .env file
        sudo bash -c "cat > /opt/financial-news-engine/.env << EOL
        ELASTICSEARCH_URL=$ES_URL
        ELASTICSEARCH_API_KEY=$ES_API_KEY
        ELASTICSEARCH_INDEX=$ES_INDEX
        ES_NUMBER_OF_SHARDS=$ES_SHARDS
        ES_NUMBER_OF_REPLICAS=$ES_REPLICAS
        ENVIRONMENT=$ENV
        CORS_ALLOWED_ORIGINS=https://financialnewsengine.com,https://www.financialnewsengine.com,http://localhost:3000
        EOL"

        # Set secure permissions
        sudo chmod 600 /opt/financial-news-engine/.env
        echo "Created .env file with environment variables from SSM Parameter Store" >&2

        # Output parameters retrieved (with API key redacted)
        echo "Environment loaded with the following parameters:" >&2
        echo "ELASTICSEARCH_URL=$ES_URL" >&2
        echo "ELASTICSEARCH_API_KEY=****REDACTED****" >&2
        echo "ELASTICSEARCH_INDEX=$ES_INDEX" >&2
        echo "ES_NUMBER_OF_SHARDS=$ES_SHARDS" >&2
        echo "ES_NUMBER_OF_REPLICAS=$ES_REPLICAS" >&2
        echo "ENVIRONMENT=$ENV" >&2
        EOF
      
      # Create deploy.sh script at runtime
      - |
        cat > api/deploy/deploy.sh << 'EOF'
        #!/bin/bash
        # deploy.sh - Script to deploy the application to the EC2 instance
        
        set -e
        set -o pipefail
        
        APP_DIR="/opt/financial-news-engine"
        LOG_DIR="$APP_DIR/logs"
        DEPLOY_SCRIPTS_DIR="$APP_DIR/deploy_scripts"
        SERVICE_NAME="financial-news"
        USER=$(whoami)
        
        echo "Starting deployment process as user: $USER"
        
        # Create application directory and log directory
        sudo mkdir -p $APP_DIR
        sudo mkdir -p $LOG_DIR
        sudo mkdir -p $DEPLOY_SCRIPTS_DIR
        
        # Create directory structure according to architecture document
        echo "Creating directory structure according to architecture"
        # Ensure ES database directory exists
        sudo mkdir -p $APP_DIR/es_database
        sudo touch $APP_DIR/es_database/__init__.py
        
        # Ensure scraper directory exists
        sudo mkdir -p $APP_DIR/scraper
        sudo mkdir -p $APP_DIR/scraper/data
        sudo mkdir -p $APP_DIR/scraper/articles
        sudo touch $APP_DIR/scraper/__init__.py
        
        # Ensure API directory exists
        sudo mkdir -p $APP_DIR/api
        
        # Ensure backend-scripts directory exists
        sudo mkdir -p $APP_DIR/backend-scripts
        
        # Ensure utils directory exists
        sudo mkdir -p $APP_DIR/utils
        
        # Check if app.py exists in the temp directory
        if [ ! -f "/tmp/api-deploy/app.py" ]; then
            echo "ERROR: app.py file not found in /tmp/api-deploy/"
            echo "Checking for alternate locations..."
            find /tmp -name "app.py" -type f 2>/dev/null
            exit 1
        fi
        
        # Copy files from temp directory
        echo "Copying application files to $APP_DIR"
        sudo cp /tmp/api-deploy/app.py $APP_DIR/app.py
        sudo cp /tmp/api-deploy/requirements.txt $APP_DIR/requirements.txt
        
        # Copy deployment scripts if they exist
        if [ -d "/tmp/api-deploy/api-scripts" ]; then
            echo "Copying deployment scripts"
            sudo cp -r /tmp/api-deploy/api-scripts/* $DEPLOY_SCRIPTS_DIR/
            sudo chmod +x $DEPLOY_SCRIPTS_DIR/*.sh
        fi
        
        # Set correct permissions
        echo "Setting permissions"
        sudo chown -R ubuntu:ubuntu $APP_DIR
        sudo chmod -R 755 $APP_DIR
        
        # Install dependencies
        echo "Installing Python dependencies"
        sudo pip3 install -r $APP_DIR/requirements.txt
        
        # Create systemd service
        echo "Creating systemd service"
        # First check if the service file exists in the deployment scripts
        if [ -f "$DEPLOY_SCRIPTS_DIR/financial-news.service" ]; then
            echo "Using service file from deployment scripts"
            sudo cp $DEPLOY_SCRIPTS_DIR/financial-news.service /etc/systemd/system/financial-news.service
        else
            echo "Creating service file from template"
            sudo bash -c 'cat > /etc/systemd/system/financial-news.service << EOF
        [Unit]
        Description=Financial News API Service
        After=network.target
        
        [Service]
        Type=simple
        User=ubuntu
        WorkingDirectory=/opt/financial-news-engine
        Environment=PYTHONUNBUFFERED=1
        ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py
        Restart=on-failure
        RestartSec=5
        StandardOutput=append:/opt/financial-news-engine/logs/backend.log
        StandardError=append:/opt/financial-news-engine/logs/backend.log
        SyslogIdentifier=financial-news
        
        [Install]
        WantedBy=multi-user.target
        EOF'
        fi
        
        # Ensure service file has correct permissions
        sudo chmod 644 /etc/systemd/system/financial-news.service
        
        # Run the env file creation script
        echo "Creating environment file"
        $DEPLOY_SCRIPTS_DIR/create_env_file.sh
        
        # Reload systemd and restart service
        echo "Reloading systemd and starting service"
        sudo systemctl daemon-reload
        sudo systemctl enable financial-news.service
        sudo systemctl restart financial-news.service
        
        # Verify service is running
        echo "Checking service status"
        sudo systemctl status financial-news.service
        
        echo "Deployment completed successfully"
        exit 0
        EOF
      
      # Create verify.sh script at runtime
      - |
        cat > api/deploy/verify.sh << 'EOF'
        #!/bin/bash
        # verify.sh - Verification script for checking if the deployment was successful
        
        set -e
        
        APP_DIR="/opt/financial-news-engine"
        SERVICE_NAME="financial-news"
        MAX_RETRY=10
        RETRY_INTERVAL=5
        
        echo "Starting application verification..."
        
        # Check if files exist and have correct permissions
        check_files() {
            echo "Checking if required application files exist..."
            
            if [ -f "$APP_DIR/app.py" ]; then
                echo "✅ app.py exists."
            else
                echo "❌ app.py is missing."
                ls -la $APP_DIR
                return 1
            fi
            
            if [ -f "$APP_DIR/requirements.txt" ]; then
                echo "✅ requirements.txt exists."
            else
                echo "❌ requirements.txt is missing."
                return 1
            fi
            
            if [ -f "$APP_DIR/.env" ]; then
                echo "✅ .env file exists."
                # Check permissions
                PERMS=$(stat -c "%a" $APP_DIR/.env)
                if [ "$PERMS" == "600" ]; then
                    echo "✅ .env has correct permissions (600)."
                else
                    echo "❌ .env has incorrect permissions: $PERMS, should be 600."
                    return 1
                fi
                
                # Check if env file has debug output
                if grep -q "Fetching parameter" $APP_DIR/.env; then
                    echo "❌ .env file contains debug output, which might cause application errors."
                    echo "First 5 lines of .env file:"
                    head -n 5 $APP_DIR/.env
                    return 1
                else
                    echo "✅ .env file format looks correct."
                fi
            else
                echo "❌ .env file is missing."
                return 1
            fi
            
            # Check directory structure according to architecture document
            echo "Checking directory structure..."
            for dir in "es_database" "scraper" "api" "backend-scripts" "utils" "logs"; do
                if [ -d "$APP_DIR/$dir" ]; then
                    echo "✅ $dir directory exists."
                else 
                    echo "❌ $dir directory is missing."
                    return 1
                fi
            done
            
            return 0
        }
        
        # Check if the service file exists and is properly configured
        check_service_file() {
            echo "Checking service file..."
            
            if [ -f "/etc/systemd/system/$SERVICE_NAME.service" ]; then
                echo "✅ Service file exists."
                
                # Check if service file has proper content
                if grep -q "ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py" "/etc/systemd/system/$SERVICE_NAME.service"; then
                    echo "✅ Service file has correct ExecStart."
                else
                    echo "❌ Service file has incorrect ExecStart."
                    cat "/etc/systemd/system/$SERVICE_NAME.service"
                    return 1
                fi
            else
                echo "❌ Service file is missing."
                return 1
            fi
            
            return 0
        }
        
        # Check if the service is running
        check_service() {
            echo "Checking if $SERVICE_NAME service is running..."
            
            if systemctl is-active --quiet $SERVICE_NAME; then
                echo "✅ Service $SERVICE_NAME is running."
                return 0
            else
                echo "❌ Service $SERVICE_NAME is not running."
                
                # Print service status and logs for debugging
                echo "Service status:"
                sudo systemctl status $SERVICE_NAME || true
                
                echo "Service logs:"
                sudo journalctl -u $SERVICE_NAME -n 20 || true
                
                echo "Checking log files:"
                ls -la $APP_DIR/logs/
                
                if [ -f "$APP_DIR/logs/backend.log" ]; then
                    echo "Last 20 lines of error log:"
                    tail -n 20 $APP_DIR/logs/backend.log
                fi
                
                return 1
            fi
        }
        
        # Check if the application is responding
        check_application() {
            echo "Checking if application is responding to requests..."
            
            # Try to access the health endpoint
            local response=""
            local retry_count=0
            local success=false
            local endpoints=("/health" "/api/health" "/api/v1/health" "/")
            
            while [ $retry_count -lt $MAX_RETRY ]; do
                # Try different health check endpoints
                for endpoint in "${endpoints[@]}"; do
                    echo "Trying endpoint: $endpoint"
                    if response=$(curl -s http://localhost:5000$endpoint 2>/dev/null); then
                        if [[ "$response" == *"healthy"* || "$response" == *"status"* || "$response" == *"ok"* ]]; then
                            echo "✅ Application is responding correctly on endpoint: $endpoint"
                            echo "Response: $response"
                            success=true
                            break 2
                        else
                            echo "Endpoint $endpoint responded but did not contain health check indicators."
                            echo "Response: $response"
                        fi
                    else
                        echo "Endpoint $endpoint not responding"
                    fi
                done
                
                echo "Application not responding yet, retrying in $RETRY_INTERVAL seconds... (attempt $((retry_count + 1))/$MAX_RETRY)"
                sleep $RETRY_INTERVAL
                retry_count=$((retry_count + 1))
            done
            
            if [ "$success" = false ]; then
                echo "❌ Application is not responding properly after $MAX_RETRY attempts."
                echo "Checking if application is running:"
                ps aux | grep python | grep app.py
                echo "Checking port 5000:"
                netstat -tulpn | grep 5000 || true
                
                echo "Checking for common errors in logs:"
                if [ -f "$APP_DIR/logs/backend.log" ]; then
                    echo "Checking for errors in backend.log:"
                    grep -i "error\|exception\|failed" $APP_DIR/logs/backend.log | tail -n 20 || true
                fi
                
                echo "Checking for Python import errors:"
                if [ -f "$APP_DIR/app.py" ]; then
                    echo "Running Python syntax check on app.py:"
                    python3 -m py_compile $APP_DIR/app.py || true
                fi
                
                echo "Checking system logs for application errors:"
                sudo grep -i "financial-news\|python\|error" /var/log/syslog | tail -n 20 || true
                
                return 1
            fi
            
            return 0
        }
        
        # Main verification function
        main() {
            local errors=0
            
            # Run all checks
            check_files || errors=$((errors + 1))
            check_service_file || errors=$((errors + 1))
            check_service || errors=$((errors + 1))
            check_application || errors=$((errors + 1))
            
            # Report results
            if [ $errors -eq 0 ]; then
                echo "✅ All verification checks passed! Application is running correctly."
                return 0
            else
                echo "❌ $errors verification checks failed. Please check the logs for details."
                return 1
            fi
        }
        
        # Run the main function
        main
        exit $?
        EOF
      
      # Create extract_app.py script at runtime
      - |
        cat > api/deploy/api-scripts/extract_app.py << 'EOF'
        #!/usr/bin/env python3
        """
        Extract application code from a source file and create app.py
        This script analyzes a larger codebase file and extracts the relevant 
        application code needed for deployment.
        """
        
        import os
        import re
        import sys
        
        def extract_app_code():
            """
            Extract application code from source files and create a standalone app.py
            """
            # Define potential source files
            source_files = [
                "backend.py",
                "app.py",
                "../backend.py",
                "../app.py"
            ]
            
            # Find the first existing source file
            source_file = None
            for file_path in source_files:
                if os.path.exists(file_path):
                    source_file = file_path
                    break
            
            if not source_file:
                print("Error: Could not find any source files")
                sys.exit(1)
            
            print(f"Found source file: {source_file}")
            
            # Read the source file
            with open(source_file, 'r') as file:
                content = file.read()
            
            # Create destination directory if it doesn't exist
            os.makedirs("api/deploy", exist_ok=True)
            
            # Write content to app.py with minimal processing
            with open("api/deploy/app.py", 'w') as file:
                file.write(content)
            
            print(f"Created app.py from {source_file}")
            
            # Check for requirements.txt
            if not os.path.exists("api/deploy/requirements.txt"):
                if os.path.exists("requirements.txt"):
                    with open("requirements.txt", 'r') as src:
                        with open("api/deploy/requirements.txt", 'w') as dest:
                            dest.write(src.read())
                    print("Copied requirements.txt")
                else:
                    # Create minimal requirements file
                    with open("api/deploy/requirements.txt", 'w') as file:
                        file.write("flask\nelasticsearch\npython-dotenv\n")
                    print("Created minimal requirements.txt")
        
        if __name__ == "__main__":
            extract_app_code()
        EOF
      
      # Make scripts executable
      - "chmod +x api/deploy/api-scripts/extract_app.py"
      - "chmod +x api/deploy/api-scripts/create_env_file.sh"
      - "chmod +x api/deploy/deploy.sh"
      - "chmod +x api/deploy/verify.sh"
      
      # Create lifecycle_handler.sh script
      - |
        cat > api/deploy/api-scripts/lifecycle_handler.sh << 'EOF'
        #!/bin/bash
        # lifecycle_handler.sh - Handler for Auto Scaling Group lifecycle events
        # This script manages the ASG lifecycle hooks for graceful instance termination

        set -e
        set -o pipefail

        # Colors for output
        GREEN='\033[0;32m'
        RED='\033[0;31m'
        YELLOW='\033[0;33m'
        NC='\033[0m' # No Color

        LOG_FILE="/var/log/asg-lifecycle.log"
        APP_NAME="financial-news"
        LIFECYCLE_STATE_FILE="/var/run/financial-news-lifecycle-hook-state"

        function log_message() {
            local message="$1"
            local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
            echo -e "[$timestamp] $message" | tee -a "$LOG_FILE"
        }

        # Ensure log directory exists
        mkdir -p "$(dirname "$LOG_FILE")"
        touch "$LOG_FILE"
        chmod 644 "$LOG_FILE"

        log_message "${GREEN}Starting lifecycle handler script${NC}"

        # Get the EC2 instance ID
        INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
        if [ -z "$INSTANCE_ID" ]; then
            log_message "${RED}ERROR: Could not retrieve instance ID from metadata service${NC}"
            exit 1
        fi
        log_message "Instance ID: $INSTANCE_ID"

        # Get the Auto Scaling Group name
        ASG_NAME=$(aws autoscaling describe-auto-scaling-instances \
            --instance-ids "$INSTANCE_ID" \
            --query "AutoScalingInstances[0].AutoScalingGroupName" \
            --output text 2>/dev/null)
            
        if [ -z "$ASG_NAME" ] || [ "$ASG_NAME" == "None" ]; then
            log_message "${YELLOW}WARNING: Could not retrieve Auto Scaling Group name for instance $INSTANCE_ID${NC}"
            # Not running in an ASG, nothing to do
            exit 0
        fi
        log_message "Auto Scaling Group: $ASG_NAME"

        function handle_pending_termination() {
            log_message "${YELLOW}Received termination notification for instance $INSTANCE_ID${NC}"
            
            # Gracefully stop the application to prevent disruptions
            if systemctl is-active --quiet $APP_NAME; then
                log_message "Stopping $APP_NAME service"
                systemctl stop $APP_NAME
            else
                log_message "${YELLOW}$APP_NAME service is not running${NC}"
            fi
            
            # Perform any cleanup needed
            log_message "Performing cleanup operations"
            
            # Wait a moment to ensure the service has stopped
            sleep 5
            
            # Complete the lifecycle action
            log_message "${GREEN}Completing lifecycle action${NC}"
            aws autoscaling complete-lifecycle-action \
                --lifecycle-hook-name "$1" \
                --auto-scaling-group-name "$ASG_NAME" \
                --lifecycle-action-result CONTINUE \
                --instance-id "$INSTANCE_ID"
            
            # Write state file to indicate we've handled termination
            echo "TERMINATION_HANDLED" > "$LIFECYCLE_STATE_FILE"
            
            log_message "${GREEN}Lifecycle action completed, instance ready for termination${NC}"
        }

        function register_with_load_balancer() {
            log_message "Registering instance with load balancer"
            
            # Usually automatic, but you can add custom logic here if needed
            
            # Start the application service
            if [ -f "/etc/systemd/system/$APP_NAME.service" ]; then
                log_message "Starting $APP_NAME service"
                systemctl start $APP_NAME
            else
                log_message "${YELLOW}$APP_NAME service definition not found${NC}"
            fi
        }

        # Check if we're running as part of an instance termination
        if [ "$1" = "TERMINATING" ]; then
            handle_pending_termination "$2"
            exit 0
        fi

        # Otherwise, assume we're starting up
        log_message "Instance startup detected"
        register_with_load_balancer
        log_message "${GREEN}Lifecycle handler completed startup tasks${NC}"

        exit 0
        EOF
      
      # Make lifecycle handler executable
      - "chmod +x api/deploy/api-scripts/lifecycle_handler.sh"
      
      # Copy service file to api-scripts deployment directory
      - |
        if [ -f "buildspecs/api-deploy/api-scripts/financial-news.service" ]; then
          cp buildspecs/api-deploy/api-scripts/financial-news.service api/deploy/api-scripts/
        else
          cat > api/deploy/api-scripts/financial-news.service << 'EOF'
        [Unit]
        Description=Financial News API Service
        After=network.target

        [Service]
        Type=simple
        User=ubuntu
        WorkingDirectory=/opt/financial-news-engine
        Environment=PYTHONUNBUFFERED=1
        ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py
        Restart=on-failure
        RestartSec=5
        StandardOutput=append:/opt/financial-news-engine/logs/backend.log
        StandardError=append:/opt/financial-news-engine/logs/backend.log
        SyslogIdentifier=financial-news

        [Install]
        WantedBy=multi-user.target
        EOF
        fi
      
      # Execute app extraction if needed
      - "if [ ! -f \"api/deploy/app.py\" ]; then python3 api/deploy/api-scripts/extract_app.py; fi"
  
  build:
    commands:
      - "echo \"Getting backend instances from Auto Scaling Group\""
      - "ASG_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='BackendAutoScalingGroupName'].OutputValue\" --output text)"
      - "echo \"Auto Scaling Group $ASG_NAME\""
      - "INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME --query \"AutoScalingGroups[0].Instances[?LifecycleState=='InService'].InstanceId\" --output text)"
      - "echo \"Instance IDs $INSTANCE_IDS\""
      - "if [ -z \"$INSTANCE_IDS\" ]; then echo \"No running instances found in Auto Scaling Group\"; exit 0; fi"
      
      # Check for SSM permissions
      - "echo \"Checking for SSM permissions\""
      - |
        SSM_TEST=$(aws ssm describe-instance-information --output json 2>&1 || echo "SSM_PERMISSION_ERROR")
        if [[ $SSM_TEST == *"SSM_PERMISSION_ERROR"* ]]; then
          echo "WARNING: CodeBuild role lacks SSM permissions. Skipping direct instance deployment."
          echo "Please add ssm:SendCommand and ssm:DescribeInstanceInformation permissions to the CodeBuild role."
          echo "Files will still be uploaded to S3 for later deployment."
          SKIP_SSM_DEPLOY=true
        else
          SKIP_SSM_DEPLOY=false
        fi
      
      # Upload files to S3 for transfer
      - "echo \"Uploading deployment files to S3\""
      - "aws s3 cp api/deploy/app.py s3://$ASSETS_BUCKET_NAME/temp/app.py"
      - "aws s3 cp api/deploy/requirements.txt s3://$ASSETS_BUCKET_NAME/temp/requirements.txt"
      - "aws s3 cp api/deploy/deploy.sh s3://$ASSETS_BUCKET_NAME/temp/deploy.sh"
      - "aws s3 cp api/deploy/verify.sh s3://$ASSETS_BUCKET_NAME/temp/verify.sh"
      - "aws s3 cp api/deploy/api-scripts/create_env_file.sh s3://$ASSETS_BUCKET_NAME/temp/api-scripts/create_env_file.sh"
      - "aws s3 cp api/deploy/api-scripts/lifecycle_handler.sh s3://$ASSETS_BUCKET_NAME/temp/api-scripts/lifecycle_handler.sh"
      - "aws s3 cp api/deploy/api-scripts/financial-news.service s3://$ASSETS_BUCKET_NAME/temp/api-scripts/financial-news.service"
      
      # Deploy to each instance
      - "echo \"Deploying to instances\""
      - |
        if [ "$SKIP_SSM_DEPLOY" = "false" ]; then
          for INSTANCE_ID in $INSTANCE_IDS; do 
            echo "Deploying to instance $INSTANCE_ID"
            aws ssm send-command --document-name "AWS-RunShellScript" --targets "Key=InstanceIds,Values=$INSTANCE_ID" --parameters "commands=['mkdir -p /tmp/api-deploy /tmp/api-deploy/api-scripts']" --comment "Create staging directory" --output text || echo "Failed to create staging directory on $INSTANCE_ID"
            if [ $? -eq 0 ]; then
              DEPLOY_CMD="cd /tmp && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/app.py api-deploy/ && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/requirements.txt api-deploy/ && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/deploy.sh api-deploy/ && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/verify.sh api-deploy/ && mkdir -p api-deploy/api-scripts && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/api-scripts/create_env_file.sh api-deploy/api-scripts/ && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/api-scripts/lifecycle_handler.sh api-deploy/api-scripts/ && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/api-scripts/financial-news.service api-deploy/api-scripts/ && chmod +x api-deploy/deploy.sh api-deploy/verify.sh api-deploy/api-scripts/create_env_file.sh api-deploy/api-scripts/lifecycle_handler.sh && cd api-deploy && ./deploy.sh && ./verify.sh"
              aws ssm send-command --document-name "AWS-RunShellScript" --targets "Key=InstanceIds,Values=$INSTANCE_ID" --parameters "commands=[\"$DEPLOY_CMD\"]" --comment "Deploy and verify API" --output text || echo "Failed to deploy to $INSTANCE_ID"
              echo "Deployment to instance $INSTANCE_ID completed"
            fi
          done
        else
          echo "Skipping direct instance deployment due to missing SSM permissions"
        fi
  
  post_build:
    commands:
      - "echo \"Creating API configuration YAML\""
      - "echo \"---\" > backend-api.yaml"
      - "echo \"# Financial News Engine API Configuration\" >> backend-api.yaml"
      - "echo \"app_code: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/app.py >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"requirements: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/requirements.txt >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"service_definition: |\" >> backend-api.yaml"
      - "echo \"[Unit]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Description=Financial News API Service\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"After=network.target\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"[Service]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Type=simple\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"User=ubuntu\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"WorkingDirectory=/opt/financial-news-engine\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Environment=PYTHONUNBUFFERED=1\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Restart=on-failure\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"RestartSec=5\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"StandardOutput=append:/opt/financial-news-engine/logs/backend.log\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"StandardError=append:/opt/financial-news-engine/logs/backend.log\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"SyslogIdentifier=financial-news\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"[Install]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"WantedBy=multi-user.target\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"verification_script: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/verify.sh >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"create_env_file_script: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/api-scripts/create_env_file.sh >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"lifecycle_handler_script: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/api-scripts/lifecycle_handler.sh >> backend-api.yaml"
      
      - "echo \"Uploading API code to S3\""
      - "aws s3 cp backend-api.yaml s3://$ASSETS_BUCKET_NAME/api/backend-api.yaml"
      
      - "echo \"Starting ASG instance refresh\""
      - "ASG_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='BackendAutoScalingGroupName'].OutputValue\" --output text)"
      - |
        if [ -n "$ASG_NAME" ]; then 
          echo "Found ASG $ASG_NAME"
          # Check if instance refresh is already in progress
          REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes --auto-scaling-group-name $ASG_NAME --query "InstanceRefreshes[?Status=='InProgress']" --output json)
          if [[ $REFRESH_STATUS == *"[]"* ]]; then
            REFRESH_ID=$(aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 50, "InstanceWarmup": 300}' --query "InstanceRefreshId" --output text)
            if [ -n "$REFRESH_ID" ]; then 
              echo "Started instance refresh with ID $REFRESH_ID"
            else 
              echo "WARNING: Could not start instance refresh"
            fi
          else
            echo "WARNING: Instance refresh already in progress, skipping new refresh"
          fi
        else 
          echo "WARNING: Could not find Auto Scaling Group name"
        fi
      
      - "echo \"API deployment completed\""

artifacts:
  files:
    - "api/deploy/**/*"
    - "api-scripts/**/*" 