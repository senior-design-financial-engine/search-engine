version: 0.2

phases:
  install:
    runtime-versions:
      python: 3.9
    commands:
      - "echo \"Installing required tools\""
      - "pip install pyyaml boto3 awscli jq"
  
  pre_build:
    commands:
      - "echo \"Preparing API code for deployment\""
      - "cd backend || (echo \"Backend directory not found, using project root\"; cd .)"
      - "mkdir -p api/deploy/deploy_scripts"
      - "cp backend.py api/deploy/app.py || cp app.py api/deploy/app.py || echo \"Using fallback app.py\""
      - "cp requirements.txt api/deploy/requirements.txt || echo \"Using fallback requirements.txt\""
      
      # Get assets bucket name from CloudFormation
      - "echo \"Getting assets bucket name from CloudFormation\""
      - "export ASSETS_BUCKET_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='AssetsBucketName'].OutputValue\" --output text)"
      - "echo \"Assets bucket name: $ASSETS_BUCKET_NAME\""
      
      # Create deploy.sh script at runtime
      - "echo \"Creating deployment scripts\""
      - |
        cat > api/deploy/deploy.sh << 'EOF'
        #!/bin/bash
        # deploy.sh - Script to deploy the application to the EC2 instance
        
        set -e
        set -o pipefail
        
        APP_DIR="/opt/financial-news-engine"
        LOG_DIR="$APP_DIR/logs"
        DEPLOY_SCRIPTS_DIR="$APP_DIR/deploy_scripts"
        SERVICE_NAME="financial-news"
        USER=$(whoami)
        
        echo "Starting deployment process as user: $USER"
        
        # Create application directory and log directory
        sudo mkdir -p $APP_DIR
        sudo mkdir -p $LOG_DIR
        sudo mkdir -p $DEPLOY_SCRIPTS_DIR
        
        # Copy files from temp directory
        echo "Copying application files to $APP_DIR"
        sudo cp /tmp/api-deploy/app.py $APP_DIR/app.py
        sudo cp /tmp/api-deploy/requirements.txt $APP_DIR/requirements.txt
        
        # Copy deployment scripts if they exist
        if [ -d "/tmp/api-deploy/deploy_scripts" ]; then
            echo "Copying deployment scripts"
            sudo cp -r /tmp/api-deploy/deploy_scripts/* $DEPLOY_SCRIPTS_DIR/
        fi
        
        # Set correct permissions
        echo "Setting permissions"
        sudo chown -R ubuntu:ubuntu $APP_DIR
        sudo chmod -R 755 $APP_DIR
        
        # Install dependencies
        echo "Installing Python dependencies"
        sudo pip3 install -r $APP_DIR/requirements.txt
        
        # Create systemd service
        echo "Creating systemd service"
        sudo bash -c 'cat > /etc/systemd/system/financial-news.service << EOF
        [Unit]
        Description=Financial News API Service
        After=network.target
        
        [Service]
        Type=simple
        User=ubuntu
        WorkingDirectory=/opt/financial-news-engine
        Environment=PYTHONUNBUFFERED=1
        ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py
        Restart=on-failure
        RestartSec=5
        StandardOutput=append:/opt/financial-news-engine/logs/service-output.log
        StandardError=append:/opt/financial-news-engine/logs/service-error.log
        SyslogIdentifier=financial-news
        
        [Install]
        WantedBy=multi-user.target
        EOF'
        
        # Reload systemd and restart service
        echo "Reloading systemd and starting service"
        sudo systemctl daemon-reload
        sudo systemctl enable financial-news.service
        sudo systemctl restart financial-news.service
        
        echo "Deployment completed successfully"
        exit 0
        EOF
      
      # Create verify.sh script at runtime
      - |
        cat > api/deploy/verify.sh << 'EOF'
        #!/bin/bash
        # verify.sh - Verification script for checking if the deployment was successful
        
        set -e
        
        APP_DIR="/opt/financial-news-engine"
        SERVICE_NAME="financial-news"
        MAX_RETRY=10
        RETRY_INTERVAL=5
        
        echo "Starting application verification..."
        
        # Check if the service is running
        check_service() {
            echo "Checking if $SERVICE_NAME service is running..."
            
            if systemctl is-active --quiet $SERVICE_NAME; then
                echo "✅ Service $SERVICE_NAME is running."
                return 0
            else
                echo "❌ Service $SERVICE_NAME is not running."
                
                # Print service status and logs for debugging
                echo "Service status:"
                sudo systemctl status $SERVICE_NAME || true
                
                echo "Service logs:"
                sudo journalctl -u $SERVICE_NAME -n 20 || true
                
                return 1
            fi
        }
        
        # Check if the application is responding
        check_application() {
            echo "Checking if application is responding to requests..."
            
            # Try to access the health endpoint
            local response=""
            local retry_count=0
            local success=false
            
            while [ $retry_count -lt $MAX_RETRY ]; do
                if response=$(curl -s http://localhost:5000/health 2>/dev/null); then
                    if [[ "$response" == *"healthy"* ]]; then
                        echo "✅ Application is responding correctly."
                        success=true
                        break
                    fi
                fi
                
                echo "Application not responding yet, retrying in $RETRY_INTERVAL seconds... (attempt $((retry_count + 1))/$MAX_RETRY)"
                sleep $RETRY_INTERVAL
                retry_count=$((retry_count + 1))
            done
            
            if [ "$success" = false ]; then
                echo "❌ Application is not responding properly after $MAX_RETRY attempts."
                return 1
            fi
            
            return 0
        }
        
        # Check application files
        check_files() {
            echo "Checking if required application files exist..."
            
            if [ -f "$APP_DIR/app.py" ]; then
                echo "✅ app.py exists."
            else
                echo "❌ app.py is missing."
                return 1
            fi
            
            if [ -f "$APP_DIR/requirements.txt" ]; then
                echo "✅ requirements.txt exists."
            else
                echo "❌ requirements.txt is missing."
                return 1
            fi
            
            return 0
        }
        
        # Main verification function
        main() {
            local errors=0
            
            # Run all checks
            check_files || errors=$((errors + 1))
            check_service || errors=$((errors + 1))
            check_application || errors=$((errors + 1))
            
            # Report results
            if [ $errors -eq 0 ]; then
                echo "✅ All verification checks passed! Application is running correctly."
                return 0
            else
                echo "❌ $errors verification checks failed. Please check the logs for details."
                return 1
            fi
        }
        
        # Run the main function
        main
        exit $?
        EOF
      
      # Create extract_app.py script at runtime
      - |
        cat > api/deploy/deploy_scripts/extract_app.py << 'EOF'
        #!/usr/bin/env python3
        """
        Extract application code from a source file and create app.py
        This script analyzes a larger codebase file and extracts the relevant 
        application code needed for deployment.
        """
        
        import os
        import re
        import sys
        
        def extract_app_code():
            """
            Extract application code from source files and create a standalone app.py
            """
            # Define potential source files
            source_files = [
                "backend.py",
                "app.py",
                "../backend.py",
                "../app.py"
            ]
            
            # Find the first existing source file
            source_file = None
            for file_path in source_files:
                if os.path.exists(file_path):
                    source_file = file_path
                    break
            
            if not source_file:
                print("Error: Could not find any source files")
                sys.exit(1)
            
            print(f"Found source file: {source_file}")
            
            # Read the source file
            with open(source_file, 'r') as file:
                content = file.read()
            
            # Create destination directory if it doesn't exist
            os.makedirs("api/deploy", exist_ok=True)
            
            # Write content to app.py with minimal processing
            with open("api/deploy/app.py", 'w') as file:
                file.write(content)
            
            print(f"Created app.py from {source_file}")
            
            # Check for requirements.txt
            if not os.path.exists("api/deploy/requirements.txt"):
                if os.path.exists("requirements.txt"):
                    with open("requirements.txt", 'r') as src:
                        with open("api/deploy/requirements.txt", 'w') as dest:
                            dest.write(src.read())
                    print("Copied requirements.txt")
                else:
                    # Create minimal requirements file
                    with open("api/deploy/requirements.txt", 'w') as file:
                        file.write("flask\nelasticsearch\npython-dotenv\n")
                    print("Created minimal requirements.txt")
        
        if __name__ == "__main__":
            extract_app_code()
        EOF
      
      # Make scripts executable
      - "chmod +x api/deploy/deploy_scripts/extract_app.py"
      - "chmod +x api/deploy/deploy.sh"
      - "chmod +x api/deploy/verify.sh"
      
      # Execute app extraction if needed
      - "if [ ! -f \"api/deploy/app.py\" ]; then python3 api/deploy/deploy_scripts/extract_app.py; fi"
  
  build:
    commands:
      - "echo \"Getting backend instances from Auto Scaling Group\""
      - "ASG_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='BackendAutoScalingGroupName'].OutputValue\" --output text)"
      - "echo \"Auto Scaling Group $ASG_NAME\""
      - "INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $ASG_NAME --query \"AutoScalingGroups[0].Instances[?LifecycleState=='InService'].InstanceId\" --output text)"
      - "echo \"Instance IDs $INSTANCE_IDS\""
      - "if [ -z \"$INSTANCE_IDS\" ]; then echo \"No running instances found in Auto Scaling Group\"; exit 0; fi"
      
      # Check for SSM permissions
      - "echo \"Checking for SSM permissions\""
      - |
        SSM_TEST=$(aws ssm describe-instance-information --output json 2>&1 || echo "SSM_PERMISSION_ERROR")
        if [[ $SSM_TEST == *"SSM_PERMISSION_ERROR"* ]]; then
          echo "WARNING: CodeBuild role lacks SSM permissions. Skipping direct instance deployment."
          echo "Please add ssm:SendCommand and ssm:DescribeInstanceInformation permissions to the CodeBuild role."
          echo "Files will still be uploaded to S3 for later deployment."
          SKIP_SSM_DEPLOY=true
        else
          SKIP_SSM_DEPLOY=false
        fi
      
      # Upload files to S3 for transfer
      - "echo \"Uploading deployment files to S3\""
      - "aws s3 cp api/deploy/app.py s3://$ASSETS_BUCKET_NAME/temp/app.py"
      - "aws s3 cp api/deploy/requirements.txt s3://$ASSETS_BUCKET_NAME/temp/requirements.txt"
      - "aws s3 cp api/deploy/deploy.sh s3://$ASSETS_BUCKET_NAME/temp/deploy.sh"
      - "aws s3 cp api/deploy/verify.sh s3://$ASSETS_BUCKET_NAME/temp/verify.sh"
      
      # Deploy to each instance
      - "echo \"Deploying to instances\""
      - |
        if [ "$SKIP_SSM_DEPLOY" = "false" ]; then
          for INSTANCE_ID in $INSTANCE_IDS; do 
            echo "Deploying to instance $INSTANCE_ID"
            aws ssm send-command --document-name "AWS-RunShellScript" --targets "Key=InstanceIds,Values=$INSTANCE_ID" --parameters "commands=['mkdir -p /tmp/api-deploy']" --comment "Create staging directory" --output text || echo "Failed to create staging directory on $INSTANCE_ID"
            if [ $? -eq 0 ]; then
              DEPLOY_CMD="cd /tmp/api-deploy && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/app.py . && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/requirements.txt . && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/deploy.sh . && aws s3 cp s3://$ASSETS_BUCKET_NAME/temp/verify.sh . && chmod +x deploy.sh verify.sh && ./deploy.sh && ./verify.sh"
              aws ssm send-command --document-name "AWS-RunShellScript" --targets "Key=InstanceIds,Values=$INSTANCE_ID" --parameters "commands=[\"$DEPLOY_CMD\"]" --comment "Deploy and verify API" --output text || echo "Failed to deploy to $INSTANCE_ID"
              echo "Deployment to instance $INSTANCE_ID completed"
            fi
          done
        else
          echo "Skipping direct instance deployment due to missing SSM permissions"
        fi
  
  post_build:
    commands:
      - "echo \"Creating API configuration YAML\""
      - "echo \"---\" > backend-api.yaml"
      - "echo \"# Financial News Engine API Configuration\" >> backend-api.yaml"
      - "echo \"app_code: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/app.py >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"requirements: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/requirements.txt >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"service_definition: |\" >> backend-api.yaml"
      - "echo \"[Unit]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Description=Financial News API Service\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"After=network.target\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"[Service]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Type=simple\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"User=ubuntu\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"WorkingDirectory=/opt/financial-news-engine\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Environment=PYTHONUNBUFFERED=1\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"ExecStart=/usr/bin/python3 /opt/financial-news-engine/app.py\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"Restart=on-failure\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"RestartSec=5\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"StandardOutput=append:/opt/financial-news-engine/logs/service-output.log\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"StandardError=append:/opt/financial-news-engine/logs/service-error.log\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"SyslogIdentifier=financial-news\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"[Install]\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"WantedBy=multi-user.target\" | sed 's/^/  /' >> backend-api.yaml"
      - "echo \"\" >> backend-api.yaml"
      - "echo \"verification_script: |\" >> backend-api.yaml"
      - "sed 's/^/  /' api/deploy/verify.sh >> backend-api.yaml"
      
      - "echo \"Uploading API code to S3\""
      - "aws s3 cp backend-api.yaml s3://$ASSETS_BUCKET_NAME/api/backend-api.yaml"
      
      - "echo \"Starting ASG instance refresh\""
      - "ASG_NAME=$(aws cloudformation describe-stacks --stack-name $BACKEND_STACK_NAME --query \"Stacks[0].Outputs[?OutputKey=='BackendAutoScalingGroupName'].OutputValue\" --output text)"
      - |
        if [ -n "$ASG_NAME" ]; then 
          echo "Found ASG $ASG_NAME"
          # Check if instance refresh is already in progress
          REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes --auto-scaling-group-name $ASG_NAME --query "InstanceRefreshes[?Status=='InProgress']" --output json)
          if [[ $REFRESH_STATUS == *"[]"* ]]; then
            REFRESH_ID=$(aws autoscaling start-instance-refresh --auto-scaling-group-name $ASG_NAME --preferences '{"MinHealthyPercentage": 50, "InstanceWarmup": 300}' --query "InstanceRefreshId" --output text)
            if [ -n "$REFRESH_ID" ]; then 
              echo "Started instance refresh with ID $REFRESH_ID"
            else 
              echo "WARNING: Could not start instance refresh"
            fi
          else
            echo "WARNING: Instance refresh already in progress, skipping new refresh"
          fi
        else 
          echo "WARNING: Could not find Auto Scaling Group name"
        fi
      
      - "echo \"API deployment completed\""

artifacts:
  files:
    - "api/deploy/**/*"
    - "scripts/**/*" 